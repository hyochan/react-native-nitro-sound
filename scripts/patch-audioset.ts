#!/usr/bin/env npx tsx
/**
 * Patches the generated Swift files to fix Release build optimization issues.
 * See: https://github.com/hyochan/react-native-nitro-sound/issues/741
 *
 * The nitrogen code generator uses `.value` accessor for std::optional which causes
 * corruption in Release builds. This script replaces it with the safe pattern:
 * `.has_value() ? .pointee : nil`
 */

import * as fs from 'fs';
import * as path from 'path';

const SWIFT_DIR = path.join(__dirname, '../nitrogen/generated/ios/swift');

// Files and their properties that need to be patched
const FILES_TO_PATCH: Record<string, string[]> = {
  'AudioSet.swift': [
    'AVModeIOS',
    'AVEncodingOptionIOS',
    'AVFormatIDKeyIOS',
    'AVNumberOfChannelsKeyIOS',
    'AVSampleRateKeyIOS',
    'AudioQuality',
    'AudioChannels',
    'AudioSamplingRate',
    'AudioEncodingBitRate',
  ],
  'RecordBackType.swift': ['currentMetering', 'recordSecs'],
};

function patchFile(fileName: string, properties: string[]): number {
  const filePath = path.join(SWIFT_DIR, fileName);

  if (!fs.existsSync(filePath)) {
    console.error(`  ‚ùå ${fileName} not found`);
    return 0;
  }

  let content = fs.readFileSync(filePath, 'utf-8');
  let patchCount = 0;

  for (const prop of properties) {
    // Match the unsafe pattern: return self.__PropertyName.value
    const unsafePattern = new RegExp(`return self\\.__${prop}\\.value`, 'g');
    const safeReplacement = `return self.__${prop}.has_value() ? self.__${prop}.pointee : nil`;

    if (unsafePattern.test(content)) {
      content = content.replace(unsafePattern, safeReplacement);
      patchCount++;
      console.log(`  ‚úÖ Patched: ${prop}`);
    }
  }

  // Update the header comment to indicate it's been patched (preserve DO NOT MODIFY warning)
  const originalHeader =
    '/// This file was generated by nitrogen. DO NOT MODIFY THIS FILE.';
  const patchedHeader = `/// This file was generated by nitrogen. DO NOT MODIFY THIS FILE.
/// PATCHED: Fixed .value accessors to use .has_value() ? .pointee : nil pattern
/// to fix Release build optimization issues (see #741)`;

  if (content.includes(originalHeader) && !content.includes('PATCHED:')) {
    content = content.replace(originalHeader, patchedHeader);
  }

  fs.writeFileSync(filePath, content, 'utf-8');

  return patchCount;
}

function main(): void {
  console.log('üîß Patching Swift files for Release build compatibility...\n');

  let totalPatchCount = 0;

  for (const [fileName, properties] of Object.entries(FILES_TO_PATCH)) {
    console.log(`üìÑ ${fileName}:`);
    const count = patchFile(fileName, properties);
    totalPatchCount += count;

    if (count === 0) {
      console.log('  ‚ö†Ô∏è  No properties needed patching (already patched)');
    }
    console.log('');
  }

  if (totalPatchCount > 0) {
    console.log(
      `‚úÖ Successfully patched ${totalPatchCount} properties across ${Object.keys(FILES_TO_PATCH).length} files`
    );
  } else {
    console.log('‚ö†Ô∏è  No properties needed patching (already patched)');
  }
}

main();
